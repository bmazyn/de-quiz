[

  {
    "id": "dbx-001",
    "app": "DE",
    "chapter": 1,
    "deckId": "dbx.delta.opt1",
    "difficulty": 2,
    "promptLine": "A Delta table becomes slow after many small batch inserts. What is the best action to improve read performance?",
    "choices": { "A": "VACUUM my_table", "B": "OPTIMIZE my_table", "C": "REFRESH TABLE my_table", "D": "CACHE TABLE my_table" },
    "answer": "B",
    "whyCorrect": "OPTIMIZE compacts many small files into fewer larger files, reducing file scan overhead and improving query performance.",
    "whyWrong": {
      "A": "VACUUM removes old files for storage cleanup but does not address the small-file problem.",
      "C": "REFRESH TABLE only updates metadata and does not change physical file layout.",
      "D": "CACHE TABLE may speed repeated reads temporarily but does not fix the underlying file fragmentation."
    },
    "conceptTags": ["delta", "small-files", "performance"]
  },

{
"id":"dbx-002",
"deckId":"dbx.delta.opt1",
"difficulty":2,
"promptLine":"After running OPTIMIZE on a large Delta table, what additional step improves selective query performance on a high-cardinality column?",
"choices":{
"A":"VACUUM",
"B":"ZORDER BY (column_name)",
"C":"CACHE TABLE",
"D":"REFRESH TABLE"
},
"answer":"B",
"whyCorrect":"ZORDER BY colocates related values in the same files, improving data skipping for selective filters.",
"whyWrong":{
"A":"VACUUM only removes old files and does not change data layout.",
"C":"CACHE speeds repeated reads but does not improve file pruning.",
"D":"REFRESH updates metadata only."
},
"conceptTags":["delta","zorder","performance"]
},
{
"id":"dbx-003",
"deckId":"dbx.delta.opt1",
"difficulty":2,
"promptLine":"Why do many small files reduce Delta table read performance?",
"choices":{
"A":"Spark cannot read small files",
"B":"Each file requires metadata and task overhead",
"C":"Delta blocks small files",
"D":"They prevent caching"
},
"answer":"B",
"whyCorrect":"Each file requires scheduling and metadata handling, increasing overhead and reducing scan efficiency.",
"whyWrong":{
"A":"Spark can read small files but with overhead.",
"C":"Delta does not block small files automatically.",
"D":"Caching is unrelated to file count."
},
"conceptTags":["delta","small-files","spark-internals"]
},
{
"id":"dbx-004",
"deckId":"dbx.delta.opt1",
"difficulty":2,
"promptLine":"Which scenario most likely creates a small-file problem in Delta?",
"choices":{
"A":"Large batch overwrite",
"B":"Frequent small streaming or micro-batch writes",
"C":"Running OPTIMIZE daily",
"D":"Using partition pruning"
},
"answer":"B",
"whyCorrect":"Frequent small writes create many tiny files over time.",
"whyWrong":{
"A":"Large overwrites usually create fewer larger files.",
"C":"OPTIMIZE reduces small files.",
"D":"Partition pruning does not create files."
},
"conceptTags":["delta","ingestion","streaming"]
},
{
"id":"dbx-005",
"deckId":"dbx.delta.opt1",
"difficulty":2,
"promptLine":"What is the primary purpose of VACUUM in Delta Lake?",
"choices":{
"A":"Improve query performance",
"B":"Compact small files",
"C":"Remove old data files no longer referenced",
"D":"Repartition the table"
},
"answer":"C",
"whyCorrect":"VACUUM removes obsolete files after retention period to reclaim storage.",
"whyWrong":{
"A":"VACUUM does not improve read layout.",
"B":"OPTIMIZE handles compaction.",
"D":"VACUUM does not repartition."
},
"conceptTags":["delta","vacuum","maintenance"]
},
{
"id":"dbx-006",
"deckId":"dbx.delta.opt1",
"difficulty":2,
"promptLine":"When should OPTIMIZE typically be run?",
"choices":{
"A":"After frequent small writes accumulate",
"B":"Before every SELECT query",
"C":"Only once after table creation",
"D":"Before VACUUM"
},
"answer":"A",
"whyCorrect":"OPTIMIZE is used periodically when small files accumulate.",
"whyWrong":{
"B":"Running before every query is unnecessary.",
"C":"File fragmentation happens over time.",
"D":"Order is not the primary concern."
},
"conceptTags":["delta","maintenance"]
},
{
"id":"dbx-007",
"deckId":"dbx.delta.opt1",
"difficulty":2,
"promptLine":"What problem does ZORDER primarily address?",
"choices":{
"A":"Small file count",
"B":"Data skipping efficiency for filtered queries",
"C":"Storage cleanup",
"D":"Metadata corruption"
},
"answer":"B",
"whyCorrect":"ZORDER improves data locality for frequently filtered columns.",
"whyWrong":{
"A":"OPTIMIZE handles file compaction.",
"C":"VACUUM handles cleanup.",
"D":"Unrelated."
},
"conceptTags":["delta","zorder"]
},
{
"id":"dbx-008",
"deckId":"dbx.delta.opt1",
"difficulty":2,
"promptLine":"Why might caching a Delta table not solve the small-file problem long term?",
"choices":{
"A":"Cache disables OPTIMIZE",
"B":"Cache only helps repeated queries temporarily",
"C":"Cache merges files automatically",
"D":"Cache removes partitions"
},
"answer":"B",
"whyCorrect":"Caching improves repeated access but does not change physical file layout.",
"whyWrong":{
"A":"Caching does not disable OPTIMIZE.",
"C":"Cache does not merge files.",
"D":"Cache does not alter partitions."
},
"conceptTags":["delta","cache","performance"]
},
{
"id":"dbx-009",
"deckId":"dbx.delta.opt1",
"difficulty":2,
"promptLine":"Which combination best addresses both file compaction and selective filtering?",
"choices":{
"A":"VACUUM + CACHE",
"B":"OPTIMIZE + ZORDER",
"C":"REFRESH + VACUUM",
"D":"CACHE + REFRESH"
},
"answer":"B",
"whyCorrect":"OPTIMIZE compacts files; ZORDER improves data skipping.",
"whyWrong":{
"A":"VACUUM does not compact; cache does not fix layout.",
"C":"Neither affects file organization.",
"D":"Neither affects physical layout."
},
"conceptTags":["delta","optimization","zorder"]
},
{
"id":"dbx-010",
"deckId":"dbx.delta.opt1",
"difficulty":3,
"promptLine":"A Delta table partitioned by date still has slow queries filtering by user_id. Why?",
"choices":{
"A":"Partitioning always solves filtering",
"B":"user_id is not part of partitioning or ZORDER",
"C":"VACUUM was not run",
"D":"REFRESH TABLE missing"
},
"answer":"B",
"whyCorrect":"Filtering on a non-partitioned column without ZORDER limits data skipping efficiency.",
"whyWrong":{
"A":"Partitioning helps only on partition columns.",
"C":"VACUUM is unrelated to filter pruning.",
"D":"REFRESH does not change layout."
},
"conceptTags":["delta","partitioning","zorder","performance"]
}
,


{
"id":"cli-git1-001","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":1,
"promptLine":"What does `git init` do?",
"choices":{"A":"Creates a new local Git repository","B":"Connects to a remote repository","C":"Stages all files","D":"Creates a new branch"},
"answer":"A",
"whyCorrect":"git init initializes a new repository by creating a .git directory to track changes.",
"whyWrong":{"B":"Remote connections require git remote add.","C":"Staging requires git add.","D":"Branches are created with git branch."},
"conceptTags":["git","init","repository"]
},
{
"id":"cli-git1-002","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":1,
"promptLine":"What does `git clone <url>` do?",
"choices":{"A":"Creates a new empty repo","B":"Downloads a remote repo with history","C":"Stages files","D":"Deletes local repo"},
"answer":"B",
"whyCorrect":"git clone copies a remote repository including commit history.",
"whyWrong":{"A":"git init creates empty repos.","C":"git add stages files.","D":"Clone does not delete repos."},
"conceptTags":["git","clone","remote"]
},
{
"id":"cli-git1-003","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":1,
"promptLine":"What information does `git status` provide?",
"choices":{"A":"Commit history","B":"Remote URLs","C":"Working directory and staging state","D":"Branch merge conflicts"},
"answer":"C",
"whyCorrect":"git status shows tracked/untracked files and staging status.",
"whyWrong":{"A":"History uses git log.","B":"Remotes use git remote -v.","D":"Conflicts appear during merge."},
"conceptTags":["git","status","staging"]
},
{
"id":"cli-git1-004","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":1,
"promptLine":"What is the purpose of `git add file.txt`?",
"choices":{"A":"Commit file","B":"Stage file for next commit","C":"Push to remote","D":"Delete file"},
"answer":"B",
"whyCorrect":"git add moves changes into the staging area.",
"whyWrong":{"A":"Commit requires git commit.","C":"Push requires git push.","D":"Delete uses git rm."},
"conceptTags":["git","add","staging"]
},
{
"id":"cli-git1-005","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":1,
"promptLine":"What does `git commit -m \"message\"` do?",
"choices":{"A":"Stages files","B":"Creates a snapshot of staged changes","C":"Pushes to remote","D":"Creates a branch"},
"answer":"B",
"whyCorrect":"git commit records staged changes as a new snapshot.",
"whyWrong":{"A":"git add stages.","C":"git push uploads.","D":"git branch creates branches."},
"conceptTags":["git","commit","snapshot"]
},
{
"id":"cli-git1-006","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":1,
"promptLine":"What does `git log` display?",
"choices":{"A":"File differences","B":"Remote repos","C":"Commit history","D":"Current branch only"},
"answer":"C",
"whyCorrect":"git log shows commit history including author and messages.",
"whyWrong":{"A":"Diff uses git diff.","B":"Remotes use git remote.","D":"Log shows history across branches unless filtered."},
"conceptTags":["git","log","history"]
},
{
"id":"cli-git1-007","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":2,
"promptLine":"What does `git diff` show?",
"choices":{"A":"Differences between working directory and staging area","B":"Remote differences","C":"Branch list","D":"Commit history"},
"answer":"A",
"whyCorrect":"git diff compares changes not yet staged.",
"whyWrong":{"B":"Remote diff requires comparing refs.","C":"git branch lists branches.","D":"git log shows history."},
"conceptTags":["git","diff","changes"]
},
{
"id":"cli-git1-008","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":2,
"promptLine":"What does `git rm file.txt` do?",
"choices":{"A":"Deletes file and stages deletion","B":"Removes commit history","C":"Deletes remote repo","D":"Unstages file"},
"answer":"A",
"whyCorrect":"git rm removes the file and stages that removal.",
"whyWrong":{"B":"History remains intact.","C":"Remote deletion is separate.","D":"Unstage uses git restore --staged."},
"conceptTags":["git","rm","staging"]
},
{
"id":"cli-git1-009","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":2,
"promptLine":"What does `git mv old.txt new.txt` do?",
"choices":{"A":"Renames file and stages change","B":"Commits file","C":"Pushes rename","D":"Deletes file"},
"answer":"A",
"whyCorrect":"git mv renames the file and stages the rename.",
"whyWrong":{"B":"Commit requires git commit.","C":"Push uses git push.","D":"It renames, not deletes."},
"conceptTags":["git","mv","rename"]
},
{
"id":"cli-git1-010","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":2,
"promptLine":"What does `git remote -v` show?",
"choices":{"A":"Commit history","B":"Configured remote URLs","C":"Branch list","D":"File changes"},
"answer":"B",
"whyCorrect":"git remote -v lists remotes and their fetch/push URLs.",
"whyWrong":{"A":"History uses git log.","C":"git branch lists branches.","D":"Changes use git diff."},
"conceptTags":["git","remote","configuration"]
},
{
"id":"cli-git1-011","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":2,
"promptLine":"What does `git fetch` do?",
"choices":{"A":"Downloads changes without merging","B":"Downloads and merges automatically","C":"Commits changes","D":"Deletes local branch"},
"answer":"A",
"whyCorrect":"git fetch retrieves updates but does not merge them.",
"whyWrong":{"B":"git pull merges.","C":"Commit requires git commit.","D":"Fetch does not delete branches."},
"conceptTags":["git","fetch","remote"]
},
{
"id":"cli-git1-012","app":"DE","chapter":2,"deckId":"cli.git.1","difficulty":2,
"promptLine":"What does `git pull` do?",
"choices":{"A":"Stages files","B":"Downloads and merges remote changes","C":"Creates branch","D":"Resets repository"},
"answer":"B",
"whyCorrect":"git pull = git fetch + merge, updating the current branch.",
"whyWrong":{"A":"Staging uses git add.","C":"Branch creation uses git branch.","D":"Reset uses git reset."},
"conceptTags":["git","pull","merge"]
}



]